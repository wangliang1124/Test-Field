<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>编程题</title>
  <style>
    #target {
        width: 200px;
        height: 300px;
        margin: 40px;
        background-color: tomato;
    }
  </style>
</head>
<body>
  <div id="target">我是内容</div>
  <div>
     <input type="button" id ="button1" value="1" />
     <input type="button" id ="button2" value="2" />
  </div>
  <span id="remain"></span>
  <script>
    var log = console.log.bind(console)
    // 请用原生js实现一个函数,给页面制定的任意一个元素添加一个透明遮罩(透明度可变,默认0.2),使这个区域点击无效,要求兼容IE8+及各主流浏览器,遮罩层效果如下图所示:
    function addMask(el, opacity) {
      opacity = opacity || 0.2
      var style = window.getComputedStyle(el, null)
      var rect = el.getBoundingClientRect()
      var mr = parseInt(style.marginRight)
      var ml = parseInt(style.marginLeft)
      var mb = parseInt(style.marginBottom)
      var mt = parseInt(style.marginTop)
      // console.log(style, rect, el.offsetLeft)
      var mask = document.createElement('div')
      
      mask.style.position = 'absolute' 

      mask.style.left = el.offsetLeft - mr + 'px'
      mask.style.top = el.offsetTop - mt + 'px'

      mask.style.width = rect.width + mr + ml + 'px'
      mask.style.height = rect.height + mt + mb + 'px'

      mask.style.backgroundColor = '#000'
      mask.style.zIndex = 1
      mask.style.opacity = opacity

      el.parentNode.appendChild(mask)

    }
    var target = document.getElementById('target')
    addMask(target)

    target.addEventListener('click', function () {
        console.log('click')
    }, false)

    // 请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是"今天是星期一"
    var days = ['日','一','二','三','四','五','六'];
    var date = new Date()
    console.log('今天是星期' + days[date.getDay()]) 

    // 下面这段代码想要循环延时输出结果0 1 2 3 4,请问输出结果是否正确,如果不正确,请说明为什么,并修改循环内的代码使其输出正确结果
    // for (var i = 0; i < 5; ++i) {
    //   setTimeout(function () {
    //     console.log(i + ' ')
    //   }, 100)
    // }
    // for (var i = 0; i < 5; ++i) { // 方法一
    //   (function(i) {
    //     setTimeout(function () {
    //       console.log(i + ' ')
    //     }, 1000)
    //   })(i)
    // }
    // var output = function(i) {  // 方法二
    //   setTimeout(function () {
    //     console.log(i + ' ')
    //   }, 1000)
    // }
    // for (var i = 0; i < 5; ++i) {
    //   output(i)
    // }

    // 现有一个Page类,其原型对象上有许多以post开头的方法(如postMsg);另有一拦截函数chekc,只返回ture或false.请设计一个函数,该函数应批量改造原Page的postXXX方法,在保留其原有功能的同时,为每个postXXX方法增加拦截验证功能,当check返回true时继续执行原postXXX方法,返回false时不再执行原postXXX方法
    function Page() {}

    Page.prototype = {
      constructor: Page,
      postA: function (a) {
        console.log('a:' + a)
      },
      postB: function (b) {
        console.log('b:' + b)
      },
      postC: function (c) {
        console.log('c:' + c)
      },
      check: function () {
        return Math.random() > 0.5
      }
    }

    var checkify = function(obj) {
      for (var key in obj) {
        if (key.indexOf('post') === 0 && typeof obj[key] === 'function') {
          (function(key){
            var fn = obj[key]
            obj[key] = function() {
              if (obj.check()) fn.apply(obj, arguments)
            }
          })(key)
        }
      }
    }

    checkify(Page.prototype)

    var obj = new Page()
    // log(obj)
    obj.postA('checkfy')
    obj.postB('checkfy')
    obj.postC('checkfy')

    // 编写javascript深度克隆函数deepClone
    function deepClone(obj) {
      var toString = Object.prototype.toString

      // null, undefined, non-object, function
      if (!obj || typeof obj !== 'object') {
        return obj
      }
      // Node
      if (obj.nodeType && 'cloneNode in obj') {
        return obj.cloneNode(true)
      }
      // Date
      if (toString.call(obj) === '[object Date]') {
        return new Date(obj.getTime())
      }
      // RegExp
      if (toString.call(obj) === '[object RegExp]') {
        var flags = []
        if (obj.global) flags.push('g')
        if (obj.mutilline) flags.push('m')
        if (obj.ingoreCase) flags.push('i')
        return new RegExp(obj.source, flags.join(''))
      }
      var result = null
      // Array
      // log(toString.call(obj))
      if (toString.call(obj) === '[object Array]') {
        var length = obj.length
        result = Array(length)
        // for (var i = 0; i < length; i++) {
        for (var i in obj) {
          // log(i)
          result[i] = deepClone(obj[i])
        }
      }
      // log(toString.call(obj))
      // Object
      if (toString.call(obj) === '[object Object]') {
        result = obj.constructor ? new obj.constructor : {}
        // log(result)
        for(var key in obj) {
          result[key] = deepClone(obj[key])
          // log(key)
        }
      }
      return result
    }

    function A() {
        this.a = a
    }

    var a = {
        name: 'qiu',
        birth: new Date(),
        pattern: /qiu/gim,
        container: document.body,
        hobbys: ['book', new Date(), /aaa/gim, 111]
    }

    var c = new A()
    var b = deepClone(c)
    log(b)
    var arr = Array(10, [1,true , 3])
    log(arr, deepClone(arr))

    // 补充代码,鼠标单击Button1后将Button1移动到Button2的后面
    var btn1 = document.getElementById('button1')
    var btn2 = document.getElementById('button2')

    btn1.onclick = function() {
      // btn1.parentNode.appendChild(btn1)
      btn1.parentNode.insertBefore(btn2, btn1)
    }

    // 网页中实现一个计算当年还剩多少时间的倒数计时程序,要求网页上实时动态显示"××年还剩××天××时××分××秒"
    function getRemainTime() {
      var date = new Date()
      var year = date.getFullYear()
      var remain = new Date(year + 1, 0, 1).getTime() - date.getTime()
      var text = `${year}年还剩`
      text += Math.floor(remain/(24*60*60*1000)) + '天'
      remain = remain % (24*60*60*1000)
      text += Math.floor(remain/(60*60*1000)) + '时'
      remain = remain % (60*60*1000)
      text += Math.floor(remain/(60*1000)) + '分'
      remain = remain % (60*1000)
      text += Math.floor(remain/1000) + '秒'
      return text
    }
    var remain = document.getElementById('remain')
    setInterval(function() {
      remain.innerHTML = getRemainTime()
    }, 1000)

    // 完成一个函数,接受数组作为参数,数组元素为整数或者数组,数组元素包含整数或数组,函数返回扁平化后的数组 如：[1, [2, [ [3, 4], 5], 6]] => [1, 2, 3, 4, 5, 6]
    var flatten = function(array) {
      var result = []
      for (var i = 0, length = array.length; i < length; i++) {
        var value = array[i]
        if (Array.isArray(value)) {
          result = result.concat(flatten(value))
        }else if(typeof value === 'number'){
          result.push(value)
        }
      }
      return result
    }
    log(flatten([1, [2, [ [3, 4], 5], 6]]))

    // 如何判断一个对象是否为数组
    var isArray = Array.isArray || function(obj) {
      return Object.prototype.toString.call(obj) === '[object Array]'
    }

    log(isArray(Array.prototype))

    // 请评价以下事件监听器代码并给出改进意见
    if (window.addEventListener) {
      var addListener = function (el, type, listener, useCapture) {
        el.addEventListener(type, listener, useCapture);
      };
    }
    else if (document.all) {
      addListener = function (el, type, listener) {
        el.attachEvent('on' + type, function () {
          listener.apply(el);
        });
      };
    }

    var addListener = (function(){
      if (window.addEventListener) {
        return function(el, type, handler) {
          el.addEventListener(type, handler, false)
          return handler
        }
      } else if (window.attachEvent) {
        return function(el, type, handler) {
          handler = function() {
            var event = window.event
            event.target = event.srcElement
            handler.call(el, event)
          }
          el.attachEvent('on' + type, handler)
          return handler
        }
      }
    }())

    // 如何判断一个对象是否为函数
    var isFunction = function(obj) {
      if (typeof /./ !== 'function') {
        return typeof obj === 'function'
      }
      return Object.prototype.toString.call(obj) === '[object Function]' 
    }

    log('isF:' + isFunction(() => {}))

    // 编写一个函数接受url中query string为参数,返回解析后的Object,query string使用application/x-www-form-urlencoded编码
    var q = function(query) {
      var result = {}
      query = decodeURIComponent(query).split('?')[1]
      if (!query) return result
      var pairs = query.split('&')
      for (var i = 0, len = pairs.length; i < len; i++) {
        var arr = pairs[i].split('=')
        result[arr[0]] = arr[1] ? arr[1].replace(/\+/g, ' ') : ''
      }
      return result
    }
    log(q('https://www.google.com/search?abc'))
    log(q('http%3A%2F%2Fitem.taobao.com%2Fitem.htm%3Fa%3D1%26b%3D2%26c%3D%26d%3Dxxx%26e'))

    // 解析一个完整的url,返回Object包含域与window.location相同
    var parseURL = function(url) {
      var result = {}
      var keys = ['href', 'origin', 'protocol', 'host', 'hostname', 'port', 'pathname', 'search', 'hash'];
      var regexp = /(((?:https?|ftp|file):)\/\/(([^:\/\?#]+)(:\d+)?))(\/[^?#]*)?(\?[^#]*)?(#.*)?/

      var match = regexp.exec(url)
      if (match) {
        for (var i = keys.length - 1; i >= 0; i--) {
          result[keys[i]] = match[i] ? match[i] : ''
        }
      }
      return result
    }

    log(parseURL('https://www.cnblogs.com:8080/speeding/p/5097790.html?xxx=9999#test'))

    // 完成函数getViewportSize返回指定窗口的视口尺寸
    var getViewportSize = function() {
      var width, height
      width = window.innerWidth || document.documentElement.clientWidth || documentElement.body.clientWidth
      height = window.innerHeight || document.documentElement.clientHeight || documentElement.body.clientHeight
      return {
        width,
        height
      }
    }
    log(getViewportSize())

    // 完成函数getScrollOffset返回窗口滚动条偏移量
    var getScrollOffset = function() {
      var offsetLeft, offsetTop
      var isCSS1Compat = document.compatMode === 'CSS1Compat'
      offsetLeft = window.pageXOffset || (isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft)
      offsetTop = window.pageYOffset || (isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop)
      return {
        offsetLeft,
        offsetTop
      }
    }
    log(getScrollOffset())

    // 现有一个字符串richText,是一段富文本,需要显示在页面上.有个要求,需要给其中只包含一个img元素的p标签增加一个叫pic的class.请编写代码实现.可以使用jQuery或KISSY.
    
  </script>
</body>
</html>